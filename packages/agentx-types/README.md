# @deepractice-ai/agentx-types

> Core type definitions for the Deepractice AgentX ecosystem

## Overview

`agentx-types` is a **pure TypeScript type library** that defines the domain models for building AI agents. It provides the foundational data structures for messages, LLM interactions, sessions, and Model Context Protocol (MCP) integration.

**Key Characteristics:**

- **Zero runtime dependencies** - Pure TypeScript types
- **Platform-agnostic** - Works in Node.js, Browser, and Edge runtimes
- **Contract-first design** - Single source of truth for data structures
- **Type-safe** - Discriminated unions with type guards
- **Well-documented** - Every type includes JSDoc comments
- **Domain-driven** - Clear separation between Agent's internal world and external environment

## Installation

```bash
npm install @deepractice-ai/agentx-types
# or
pnpm add @deepractice-ai/agentx-types
# or
yarn add @deepractice-ai/agentx-types
```

---

## üåç Domain Architecture

The library is organized into **two major domains**:

```
agentx-types/
‚îÇ
‚îú‚îÄ‚îÄ agent/              # Agent's Internal World
‚îÇ   ‚îú‚îÄ‚îÄ Agent.ts        # Agent data structure
‚îÇ   ‚îú‚îÄ‚îÄ message/        # How agent communicates (messages, content)
‚îÇ   ‚îú‚îÄ‚îÄ mcp/            # Agent's capabilities (tools, resources, prompts)
‚îÇ   ‚îú‚îÄ‚îÄ llm/            # Agent's brain (LLM config, requests, responses)
‚îÇ   ‚îî‚îÄ‚îÄ guards/         # Type safety (runtime type guards)
‚îÇ
‚îî‚îÄ‚îÄ environment/        # Agent's External World
    ‚îî‚îÄ‚îÄ session/        # 1-to-1 conversation snapshot
        ‚îî‚îÄ‚îÄ Session.ts
```

### Why Two Domains?

Think of it like a human in a room:

- **Agent Domain** = Human's internal world
  - How they think (LLM)
  - How they communicate (Messages)
  - What tools they can use (MCP)
  - Their identity (Agent)

- **Environment Domain** = The external room
  - Session: The conversation space where agent operates
  - Channel (future): Broadcast spaces (1-to-many)
  - Group (future): Collaboration spaces (many-to-many)

**Key Insight:**

- Session is a **snapshot** (data) that can be saved/restored
- Agent is a **runtime instance** that reads the snapshot and operates
- Session doesn't belong to Agent - Agent loads Session to "revive"

---

## üì¶ Import Paths

### Before (Old - Don't Use)

```typescript
import { Message } from "@deepractice-ai/agentx-types/message";
import { Session } from "@deepractice-ai/agentx-types/session";
```

### After (New - Use This)

```typescript
// Agent domain (internal world)
import { Message } from "@deepractice-ai/agentx-types/agent/message";
import { McpTool } from "@deepractice-ai/agentx-types/agent/mcp";
import { LLMConfig } from "@deepractice-ai/agentx-types/agent/llm";

// Environment domain (external world)
import { Session } from "@deepractice-ai/agentx-types/environment/session";

// Or import everything from root
import { Message, Session, Agent } from "@deepractice-ai/agentx-types";
```

---

## ü§ñ Agent Domain

### 1. Agent (Data Structure)

The complete data structure of an AI agent (pure data, no runtime state).

```typescript
import { Agent } from "@deepractice-ai/agentx-types";

interface Agent {
  id: string;
  name: string;
  description?: string;
  createdAt: number;
  version?: string;
  tags?: string[];
  [key: string]: unknown; // Extension point
}
```

**Example:**

```typescript
const agent: Agent = {
  id: "agent-001",
  name: "Code Review Assistant",
  description: "Helps review code and suggest improvements",
  createdAt: Date.now(),
  version: "1.0.0",
  tags: ["coding", "review"],
};
```

---

### 2. Message Types

Messages are how agents communicate. Discriminated union based on `role` field.

```typescript
import { Message, UserMessage, AssistantMessage } from "@deepractice-ai/agentx-types";

type Message =
  | UserMessage // role: "user"
  | AssistantMessage // role: "assistant"
  | SystemMessage // role: "system"
  | ToolUseMessage // role: "tool-use"
  | ErrorMessage; // role: "error"
```

#### UserMessage

Messages sent by users. Supports text, images, and files.

```typescript
interface UserMessage {
  id: string;
  role: "user";
  content: string | Array<TextPart | ImagePart | FilePart>;
  timestamp: number;
  parentId?: string; // For threading
}
```

**Example:**

```typescript
const textMessage: UserMessage = {
  id: "msg-001",
  role: "user",
  content: "Hello!",
  timestamp: Date.now(),
};

const multiModalMessage: UserMessage = {
  id: "msg-002",
  role: "user",
  content: [
    { type: "text", text: "What's in this image?" },
    { type: "image", data: "base64...", mediaType: "image/png" },
  ],
  timestamp: Date.now(),
};
```

#### AssistantMessage

Messages generated by AI assistants. Can include thinking, tool calls, and rich content.

```typescript
interface AssistantMessage {
  id: string;
  role: "assistant";
  content: string | Array<TextPart | ThinkingPart | ToolCallPart | FilePart>;
  timestamp: number;
  parentId?: string;
  usage?: TokenUsage; // Token consumption stats
}
```

**Example:**

```typescript
const response: AssistantMessage = {
  id: "msg-003",
  role: "assistant",
  content: "I'm doing well!",
  timestamp: Date.now(),
  usage: { input: 10, output: 8 },
};

const responseWithThinking: AssistantMessage = {
  id: "msg-004",
  role: "assistant",
  content: [
    { type: "thinking", reasoning: "Analyzing the request..." },
    { type: "text", text: "Here's my answer." },
  ],
  timestamp: Date.now(),
};
```

#### Content Parts

Multi-modal content through `ContentPart` types:

```typescript
type ContentPart =
  | TextPart // { type: "text", text: string }
  | ThinkingPart // { type: "thinking", reasoning: string }
  | ImagePart // { type: "image", data: string, mediaType: string }
  | FilePart // { type: "file", data: string, mediaType: string }
  | ToolCallPart // { type: "tool-call", id, name, input }
  | ToolResultPart; // { type: "tool-result", id, name, output }
```

---

### 3. MCP (Model Context Protocol)

Agent's capabilities: tools, resources, and prompts.

#### MCP Tools

```typescript
import { McpTool } from "@deepractice-ai/agentx-types/agent/mcp";

interface McpTool {
  name: string;
  description?: string;
  inputSchema: JsonSchema; // JSON Schema for parameters
}
```

**Example:**

```typescript
const weatherTool: McpTool = {
  name: "get_weather",
  description: "Get weather for a city",
  inputSchema: {
    type: "object",
    properties: {
      city: { type: "string", description: "City name" },
    },
    required: ["city"],
  },
};
```

#### MCP Resources

```typescript
interface McpResource {
  uri: string;
  name: string;
  description?: string;
  mimeType?: string;
}
```

#### MCP Prompts

```typescript
interface McpPrompt {
  name: string;
  description?: string;
  arguments?: McpPromptArgument[];
}
```

---

### 4. LLM Configuration

How agents interact with language models.

```typescript
import { LLMConfig, LLMRequest, LLMResponse } from "@deepractice-ai/agentx-types/agent/llm";

interface LLMConfig {
  model: string;
  temperature?: number; // 0-2
  maxTokens?: number;
  topP?: number;
  stopSequences?: string[];
  maxThinkingTokens?: number;
}

interface LLMRequest {
  messages: Message[];
  config: LLMConfig;
  systemPrompt?: string;
}

interface LLMResponse {
  content: string | ContentPart[];
  stopReason: StopReason;
  usage: TokenUsage;
  finishTime: Date;
}
```

---

### 5. Type Guards

Type-safe runtime checks for discriminated unions.

```typescript
import {
  isUserMessage,
  isAssistantMessage,
  isTextPart,
  isImagePart,
} from "@deepractice-ai/agentx-types";

function processMessage(message: Message) {
  if (isUserMessage(message)) {
    // TypeScript knows: message is UserMessage
    console.log("User said:", message.content);
  } else if (isAssistantMessage(message)) {
    // TypeScript knows: message is AssistantMessage
    console.log("Tokens used:", message.usage?.input);
  }
}
```

**Available guards:**

- Messages: `isUserMessage`, `isAssistantMessage`, `isSystemMessage`, `isToolUseMessage`, `isErrorMessage`
- Content: `isTextPart`, `isThinkingPart`, `isImagePart`, `isFilePart`, `isToolCallPart`, `isToolResultPart`

---

## üåç Environment Domain

### Session - 1-to-1 Conversation Snapshot

A session represents the conversation history and context between a user and an agent.

```typescript
import { Session } from "@deepractice-ai/agentx-types/environment/session";

interface Session {
  id: string;
  title: string;

  // Records the relationship
  agentId: string; // Which agent created/served this session
  userId?: string; // Which user (optional)

  // Conversation data
  messages: Message[];

  // Timestamps
  createdAt: Date;
  updatedAt: Date;

  // Extension point
  metadata?: Record<string, unknown>;
}
```

**Example:**

```typescript
const session: Session = {
  id: "session-001",
  title: "Code Review Discussion",
  agentId: "code-reviewer",
  userId: "user-123",
  messages: [
    { id: "msg-1", role: "user", content: "Review this code", timestamp: Date.now() },
    { id: "msg-2", role: "assistant", content: "Analyzing...", timestamp: Date.now() },
  ],
  createdAt: new Date(),
  updatedAt: new Date(),
};
```

#### Why agentId and userId?

**agentId (required):**

- Records which agent created/served the conversation
- Users expect continuity - they chose this specific agent
- Like your chat history with a specific friend in WeChat
- You don't randomly switch friends mid-conversation

**userId (optional):**

- Optional because some sessions don't involve users:
  - Agent-initiated tasks
  - Background workflows
  - Agent-to-agent conversations
- When present, used for permission control and user-specific filtering

#### Session as Snapshot

Think of Session as a saved game file:

```typescript
// Save session snapshot
const session: Session = {
  id: "session-1",
  agentId: "writing-coach",
  messages: [...conversationHistory],
  createdAt: new Date(),
  updatedAt: new Date(),
};
await saveSession(session);

// Later: Load session and revive agent
const session = await loadSession("session-1");
const agent = new AgentService(config);
agent.loadFromSession(session); // Revive from snapshot
await agent.send("Continue from where we left off");
```

**Key principle:** Session is data (snapshot), Agent is runtime (execution).

---

## üé® Design Philosophy

### 1. Pure Data Structures

All types represent **data**, not behavior. No methods, no runtime state.

```typescript
// ‚úÖ Good - Pure data
interface Message {
  id: string;
  role: string;
  content: string;
}

// ‚ùå Bad - Behavior mixed in
interface Message {
  id: string;
  send(): Promise<void>; // Behavior belongs in services
}
```

### 2. Discriminated Unions

Use `type` or `role` fields for type discrimination.

```typescript
type ContentPart =
  | { type: "text"; text: string }
  | { type: "image"; data: string; mediaType: string };

function render(part: ContentPart) {
  switch (part.type) {
    case "text":
      return part.text; // TypeScript knows: part.text exists
    case "image":
      return `<img src="${part.data}" />`; // TypeScript knows: part.data exists
  }
}
```

### 3. Platform-Agnostic

Types work everywhere - Node.js, Browser, Edge, Deno.

```typescript
// ‚úÖ Platform-agnostic
interface Message {
  timestamp: number; // Unix timestamp
}

// ‚ùå Platform-specific
interface Message {
  timestamp: Buffer; // Buffer only in Node.js
}
```

### 4. Extension Points

Use `metadata` or index signatures for extensibility.

```typescript
const session: Session = {
  id: "session-1",
  title: "My Session",
  agentId: "agent-1",
  messages: [],
  metadata: {
    tags: ["important"],
    customField: "value", // ‚úÖ Extensible
  },
};
```

---

## üîß Common Patterns

### Pattern 1: Creating Messages

```typescript
function createUserMessage(text: string): UserMessage {
  return {
    id: crypto.randomUUID(),
    role: "user",
    content: text,
    timestamp: Date.now(),
  };
}

function createAssistantMessage(text: string, usage?: TokenUsage): AssistantMessage {
  return {
    id: crypto.randomUUID(),
    role: "assistant",
    content: text,
    timestamp: Date.now(),
    usage,
  };
}
```

### Pattern 2: Multi-Modal Content

```typescript
const message: UserMessage = {
  id: crypto.randomUUID(),
  role: "user",
  content: [
    { type: "text", text: "Analyze this image:" },
    {
      type: "image",
      data: "data:image/png;base64,iVBORw0KGgo...",
      mediaType: "image/png",
    },
  ],
  timestamp: Date.now(),
};
```

### Pattern 3: Session Management

```typescript
// Create session
function createSession(agentId: string, userId?: string): Session {
  return {
    id: crypto.randomUUID(),
    title: "New Conversation",
    agentId,
    userId,
    messages: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}

// Load and resume
async function resumeSession(sessionId: string) {
  const session = await loadSession(sessionId);
  const agent = await createAgentForSession(session.agentId);
  agent.loadFromSession(session);
  return { session, agent };
}
```

---

## üìö Integration with Other Packages

`agentx-types` is the foundation for the entire AgentX ecosystem:

```
agentx-ui ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí agentx-framework ‚îÄ‚îÄ‚Üí agentx-core ‚îÄ‚îÄ‚Üí agentx-types
                                              ‚Üì
                                        agentx-event
```

**Usage examples:**

```typescript
// In agentx-core
import { Message, Session } from '@deepractice-ai/agentx-types';

class AgentService {
  private messages: Message[] = [];

  loadFromSession(session: Session) {
    this.messages = [...session.messages];
  }
}

// In agentx-ui
import { Message, isUserMessage } from '@deepractice-ai/agentx-types';

function ChatMessage({ message }: { message: Message }) {
  if (isUserMessage(message)) {
    return <UserBubble>{message.content}</UserBubble>;
  }
  // ...
}
```

---

## ü§ù Contributing

This package follows **strict type-only conventions**:

1. **No runtime code** - Only TypeScript types and interfaces
2. **No dependencies** - Keep the package pure
3. **One file, one primary type** - Use PascalCase filenames
4. **Domain separation** - Agent domain vs Environment domain
5. **Discriminated unions** - Always use `type` or `role` for discrimination
6. **JSDoc comments** - Document every public type

---

## üìÑ License

MIT ¬© Deepractice AI
